## Ch.7 객체지향 프로그래밍 2

1. **상속**
    - 상속 → 기존의 클래스를 재사용하여 새로운 클래스 작성
        - 새로 작성하고자하는 클래스 이름 + extends 상속받고자 하는 클래스의 이름
            - Ex) class Child(New) extends Parent(상속)
                
                ![KakaoTalk_Photo_2025-10-07-17-10-17.jpeg](attachment:c5efc3a3-c897-4d96-a555-b7dabd80d0ae:872c5bc0-c91c-4764-bbfb-24099acecf97.png)
                
        - 조상 클래스가 변경되면 자손 클래스는 자동적으로 자동적으로 영향을 받지만 반대경우에는 조상 클래스에 아무런 영향을 주지않는다 == 자손클래스는 매번 조상 클래스보다 같거나 많은 멤버를 갖는다
    - 클래스간의 관계 - 포함관계 ⇒ 다른 클래스 속성 가져오기
        
        ```java
        class Engine {
            void start() {
                System.out.println("엔진 시동 켜짐!");}}
        
        class Car {
            private Engine engine = new Engine();  // 포함관계
            void drive() {
                engine.start();  // 기능을 엔진 객체에 위임
                System.out.println("자동차가 움직입니다!"); }}
        ```
        
    - 클래스간의 관계 결정하기
        - 포함관계 VS 상속
            - 포함관계 → 한 클래스가 다른 클래스를 **멤버로 포함 / has a**
            - 상속 → 하위 클래스가 상위 클래스를 **확장 / is a**
                - Ex) 원은 점이다(is a) X / 원은 점을 가지고 있다 (has a) O 이므로 포함관계로 쓰는 것이 맞다
                    
                    ```java
                    //상속
                    class Circle extends Point{ int r; }
                    //포함
                    class Circle {Point c = new Point(); int r;}
                    ```
                    
                
                ```java
                import java.awt.*;
                
                class DrawShape{
                
                    public static void main(String[] args){
                        Point[] p = { new Point(100,100),
                                new Point(140,50),
                                new Point(200,100),
                        };
                        Triangle t = new Triangle(p);
                        Circle c = new Circle(new Point(150,150), 50);
                
                        t.draw();
                        c.draw();
                    }
                }
                
                class Shape{
                    String color = "black";
                    void draw(){
                        System.out.printf("[color=%s]%n",color);
                    }
                }
                
                class Point {
                    int x;
                    int y;
                
                    Point(int x, int y) {
                        this.x = x;
                        this.y = y;
                    }
                
                    Point() {
                        this(0, 0);
                    }
                
                    String getXY() {
                        return "( " + x + "," + y + ")";
                    }
                }
                
                    class Circle extends Shape{ // 상속
                        Point center;
                        int r;
                
                        Circle(){
                            this(new Point(0,0),100);
                
                        }
                        Circle(Point center, int r){
                            this.center = center;
                            this.r = r;
                        }
                        void draw(){
                            System.out.printf("[center = (%d, %d), r=%d, color= %s]%n", center.x,center.y,r,color);
                
                        }
                    }
                
                    class Triangle extends Shape{
                        Point[] p = new Point[3]; //포함
                
                        Triangle(Point[] p){
                            this.p = p;
                        }
                        void draw(){
                            System.out.printf("[p1= %s, p2= %s, p3=%s,color=%s] %n", p[0].getXY(),p[1].getXY(),p[2].getXY(),color);
                        }
                    }
                ```
                
    - 단일 상속 → 자바에서는 다중 상속 X, 하나의 클래스만 상속 받아야됨
        - 두개의 클래스를 받고 싶으면 하나를 포함관계로
    - Object클래스 - 모든 클래스의 조상→ 모든 인스턴스가 가져야 할 기본적인 메서드(to String(),equals()등)
2. **오버라이딩**
    - 조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것
    - 오버라이딩의 조건
        - → 자손 클래스에서 오버라이딩하는 메서드는 조상 클래스의 메서드와
            - 이름, 매개변수, 변환타입이 같아야한다
        - →조상 클래스의 메서드를 자손 클래스에서 오버라이딩할 때
            - 접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다(넓은 것부터 public, protected, (default), private)
            - 예외는 조상 클래스의 메서드보다 많이 선언할 수 없다
            - 인스턴스메서드를 static메서드 또는 그 반대로 변경할 수 없다
    - 오버로딩 → 추가 Vs 오버라이딩 → 변경
        
        ```java
        class Parent 
        	{ void parentMethod() {} }  
        	class Child extends Parent{ 
        	void parentMethod() () // 오버라이딩 
        	void parentMethod(int i) () // 오버로딩 
        	
        	void childMethod () 
        	 void childMethod(int i) // 오버로딩
        ```
        
    - super → 상속받은 멤버와 자신의 맴버와 이름이 같을 때 사용 (=this)
        - this 와 같이 static메서드에서는 사용X, 인스턴스메서드에서만 사용가능
    - super() - 조상 클래스의 생성자
        - object 클래스를 제외한 모든 클래스의 생성자 첫줄에 생성자, this()또는 super()를 호출해야함 → 안하면 자동적으로 super();를 생성자의 첫줄에 삽입
            
            ![KakaoTalk_Photo_2025-10-10-12-36-20.jpeg](attachment:205c9394-e96c-439a-82ca-081fe993fc02:KakaoTalk_Photo_2025-10-10-12-36-20.jpeg)
            
3. **Package와 import**
    - 패키지 → 클래스의 묶음
        - 하나의 소스파일에는 첫번째 문장으로 단 한번의 패키지 선언만을 허용
        - 모든 클래스는 반드시 하나의 패키지에 속해야한다
    - 패키지의 선언
        - package 패키지명
        - 소스파일에서 주석과 공백을 제외한 첫 번째 문장이어야 함
    - import문
        - import문을 사용하면 매번 클래스 이름에 패키지이름을 안써도 됨
        - 소스파일 순서 : package문 → import문 → 클래스 선언
            
            ```java
             import 패키지명.클래스명 or import 패키지명.*
            ```
            
            ```java
             // 하위 패키지의 클래스까진 포함하지않음
             import java.until.*; import java.text.*;
             -> import java.*은 할 수 없음
            ```
            
            ```java
             java.until.Date today = new java.until.Date();
             ->
             (import java.util.Date;)
            	 Date today = new Date();
            ```
            
    - static import문
        
        ```java
        	import static java.lang.System.out;
        	import static java.lang.Math.*;
        	
        	out.println(random()); //=System.out.println(Math.random());
        ```
        
4. **제어자**
    - 클래스,변수 또는 메서드의 선언부와 함께 사용되너 부가적인 의미
        - 접근제어자 → public, protected, default, private
        - 그외 → static, final,native,abstract등
    - static - 클래스의, 공통적인
        - 사용될 수 있는 곳 - 멤버변수, 메서드, 초기화블럭
            
            ![KakaoTalk_Photo_2025-10-10-14-14-08.jpeg](attachment:36bc782a-b06b-4c77-b9e7-d6936b1fe524:KakaoTalk_Photo_2025-10-10-14-14-08.jpeg)
            
    - final - 마지막의, 변경될 수 없는
        - 사용될 수 있는 곳 - 클래스, 메서드, 멤버변수, 지역변수
            
            ![KakaoTalk_Photo_2025-10-10-14-20-39.jpeg](attachment:df067f19-195b-434e-94a8-e1cc48f26057:KakaoTalk_Photo_2025-10-10-14-20-39.jpeg)
            
    - abstract - 추상의, 미완성의
        - 메서드의 선언부만 작성하고 실제 수행내용은 구현하지 않은 추상메서드를 선언
        - 사용할 수 있는 곳 → 클래스, 메서드
        - 인스턴스 생성X
    - 접근 제어자 → public, protected, default, private
        - public → 같은 클래스
        - protected → 같은 패키지
        - default → 같은 패키지 & 다른 패키지의 자손클래스에서
        - private → 접근 제한 X
        - 접근 제어자를 이용한 캡슐화
            - Getter → 멤버변수값을 읽는
            - Setter → 멤버변수의 값을 변경하는
    - 제어자의 조합
        
        ![KakaoTalk_Photo_2025-10-10-14-43-22.jpeg](attachment:a148b085-4b1c-4418-bca1-50aff08666f3:KakaoTalk_Photo_2025-10-10-14-43-22.jpeg)
        
        - 메서드에 static과 abstract를 함께 사용할 수 없다
        - 클래스에 abstract와 final을 동시에 사용할 수 없다
        - abstract메서드의 접근 제어자가 private일 수 없다
        - 메서드에 private과 final을 같이 사용할 수 없다
5. **다형성**
    - → 여러가지 형태를 가질 수 있는 능력 == 조상 클래스 타입의 참조변수로 자손 클래스의 인스턴스를 참조할 수 있도록
        
        ```java
        class Tv{
        	boolean power;
        	int channel;
        
        	void power() {power != power;}
        	void channelup {++channel;}
        	void channeldown {--channel;}
        }
        
        class CaptionTv extends Tv{
        	String text;
        	void caption();
        	}
        ```
        
        ```java
        CaptionTv c = new CaptionTv(); // 모두 다 사용 가능
        Tv t = new CaptionTv(); // Caption에서 생성한 멤버는 못씀
        == 같은 타입의 인스턴스지만 참조변수의 타입에 따라 사용할 수 있는 멤버의 개수가 달라짐
        ```
        
        ```java
        CaptionTv c = new Tv; -> 오류
        == 참조 변수가 사용할 수 있는 멤버의 개수는 인스턴스의 멤버개수보다 같거나 적어야한다
        ```
        
        - 조상타입의 참조변수로 자손타입의 인스턴스를 참조할 수 있지만 반대는 안됨
    - 참조변수의 형변환
        - 자손타입 → 조상타입(Up-casting) : 형변환 생략 가능
        - 자손타입 ← 조상타입(Down-casting) : 형변환 생략 불가능
            
            ```java
            class Car{}
            
            class FireEngine extends Car{}
            class Ambulance extends Car{}
            
            FireEngine랑 Ambulance는 서로 형변환 불가
            
            Car car = null;
            FireEngine fe = new FireEngine();
            
            car = fe; 업캐스팅이라 형변환 생략가능
            fe = (FireEngine)Car; 다운캐스팅이라 생략 불가
            //뒤에가 메인
            ```
            
    - instanceof연산자
        - 참조변수가 참조하고 있는 인스턴스의 실제 타입을 알아보기 위해  instanceof 연산자 사용
        - 왼쪽 → 참조변수, 오른쪽 → 타입(클래스명)
        - ture → 참조변수가 검사한 타입으로 형변환 가능
            
            ```java
            if (fe instanceof FireEngine){System.out.println("True")}
            -> true
            ```
            
        - 어떤 타입에 대한 instanceof연산의 결과가 true라는 것은 검사한 타입으로 형변환이 가능하다는 의미
    - 참조변수와 인스턴스의 연결
        
        ![KakaoTalk_Photo_2025-10-10-19-12-34.jpeg](attachment:a55b2e60-03ae-40d9-be92-137448f63d89:KakaoTalk_Photo_2025-10-10-19-12-34.jpeg)
        
        - 메서드인 method()는 참조변수와 관계없이 항상 실제 인스턴스의 타입인 Child클래스에 정의된 메서드가 호출되지만, 인스턴스변수인 x는 참조변수의 타입에 따라 달라진다
            
            ![KakaoTalk_Photo_2025-10-10-19-15-55.jpeg](attachment:65d85268-323c-492d-9027-4046cd0f4403:KakaoTalk_Photo_2025-10-10-19-15-55.jpeg)
            
        - super → 조상클래스
    - 매개변수의 다형성
    - 여러 종류의 객체를 배열로 다루기
        - Vector클래스 → 객체 배열
            - 10개의 객체를 저장할 수 있는 Vector인스턴 생성 , 10개 이상의 인스턴스가 저장되면 자동적으로 크기가 증가
            
            ```java
            public class Vector extends AbstractList{
            	protected Object elemnetData[];}
            ```
            
            ![KakaoTalk_Photo_2025-10-10-19-51-42.jpeg](attachment:ac559b0b-b066-45e8-9673-965c3a754f95:KakaoTalk_Photo_2025-10-10-19-51-42.jpeg)
            
6. **추상클래스**
    - 미완성 설계도(추상 메서드를 포함하고 있음)
    - 새로운 클래스를 작성하는데 조상클래스로서 중요한 의미를 가짐
    - abstract class 클래스이름{} → 생성자, 멤버변수, 메서드 가질 수 있음
    - 추상메서드 →  미완성메서드
        - 이유: 상속받는 클래스에 따라 달라질 수 있기ㅈ때문
        - 주석으로 어떤 기능을 수행할 목적인지 표시 후 상속받는 클래스에서 구현
        
        ```java
        */주석*/ 
        abstract 리턴 타입 메서드 이름(); -> 구현부가 없으므로 ;로 마무리
        
        추상 클래스로부터 상속받는 자손 클래스는 오버라이딩(변경)을 통해 추상메서드 구현해줘야됨
        abstract class Player{
        	abstract void play (int pos);
        	abstract void stop ();
        	}
        	class Au extends Player{
        	void play(int pos){생략}
        	void stop(){생략}
        	}
        ```
        
    - 추상 클래스의 작성
        - 추상화 → 기존의 클래스의 공통부분을 뽑아내서 조상 클래스를 만드는 것
            - 구체화와 반대되는 의미
            - 상속계층도를 따라 내려갈 수록 기능이 추가되어 구체화의 정도가 심해지고 올라갈수록 추상화 정도가 심해짐
                
                ```java
                abstract class Player { 
                	boolean pause; // 일시정지 상태를 저장하기 위한 변수 
                	int currentPos; // 현재 Play되고 있는 위치를 저장하기 위한 변수 
                	Player (){           // 추상클래스도 생성자가 있어야 한다. 
                			pause false; 
                			currentPos = 0; 
                			}
                // 지정된 위치 (pos)에서 재생을 시작하는 기능이 수행하도록 작성되어야 한다. 
                abstract void play(int pos); //추상메서드 
                /* 재생을 즉시 멈추는 기능을 수행하도록 작성되어야 한다. */
                abstract void stop() 
                // 추상메서드 
                void play () {
                	play (currentPos); // 추상메서드를 사용할 수 있다. 
                }
                
                void pause () {
                	if(pause) { // pause가 true일 때(정지상태)에서 pause가 호출되면, 
                			pause = false; // pause의 상태를 false로 바꾸고, 
                			play(currentPos); // 현재의 위치에서 play를 한다. 
                }
                	else ( // pause가 false일 때(play상태) 에서 pause가 호출되면, 
                			pause = true; // pause의 상태를 true로 바꾸고 
                			stop();
                }
                ```
                
                ```java
                class CDPlayer extends Player {
                	 void play (int currentPos) }
                	 /* 조상의 추상메서드를구현. 내용생략 */ 
                		void stop () {
                /* 조상의 추상메서드를구현. 내용 생략 */ 
                }
                // CDPlayer클래스에 추가로 정의된 멤버 
                int currentrrack; // 현재 재생 중인 트랙 
                
                void nextTrack () { currentTrack++;  ... }
                void preTrack () { if(currentTrack > 1) ( currentTrack--;}
                ```
                
        - 공통된 부분 뽑아서 조상 메서드
            
            ```java
            class Marine{
            	int x,y;
            	void stop();
            	void move(int x, int y);
            	void stimPack();
            }
            
            class Tank{
            	int x,y;
            	void stop();
            	void move(int x, int y);
            	void chandePack();
            }
            
            ->
            abstract class Unit{
            	int x,y;
            	abstract void move(int x, int y);
            	void stop;
            	}
            	
            	class Marine extends Unit{
            	void move(int x, int y);
            	void stimPack();
            }
            
            class Tank extends Unit{
            	void move(int x, int y);
            	void chandePack();
            }
            ```
            
7. **인터페이스**
    - 일종의 추상 클래스 → 추상메서드를 갖지만 보다 추상화정도가 높아 추상 클래스와 달리 몸통을 갖춘 일반 메서드 또는 멤버 변수를 구성원을 가질 수 없음
        
        → 오직 추상 메서드 & 상수만 멤버로 가질 수 있음
        
    - 인터페이스 작성 == 클래스작성하는 법과 비슷
        
        ```java
        interface 이름{
        	public static final 타입 상수 이름 = 값;
        	public abstract 메서드 이름(매개변수목록);
        	}
        ```
        
        - 제약사항
            - 모든 멤버 변수는 public static final이어야하며 생략가능
            - 모든 메서드는 추상메서드여야함
    - 인터페이스의 상속
        - 인터페이스로부터만 상속 받을 수 있음
        - 다중상속 가능
        - Ex) interface Fight extends Mov,Att {}
    - 인터페이스 구현
        - → 상속을 통해 추상메서드를 완성하는 것처럼 자신에 정의된 추.메의 몸통을 만들어주는 클래스 작성 ⇒ 추.클 만드는 법과 비슷 extends 대신 implements
        - interface Fight implements Mov {}
        - 구현하는 인.페 메서드중 일부만 구현한다면 추상클래스로 선언해야함
            - abstract interface Fight implements Mov {}
        - 상속과 구현 동시에 할 수 있음
            - interface Fight extends Unit implements Mov {}
            - Mov를 구현할 것
    - 인터페이스를 이용한 다중상속 → 구현하는 경우가 거의 없음
        - static 상수만 정의 가능 ==  멤버변수와 충돌하는 경우가 몇없음
    - 인터페이스를 이용한 다형성
        - 예시
            
            ```java
            Fightable f = (Fightable)new Fighter();
            or
            Fightable f = new Fighter();
            
            Fightable ->인터페이스 Fighter -> 클래스
            
            void attack(Fightable f){} -> 가능
            ```
            
            - ㅇ
            - 
        - attack메서드를 호출할 때는 매개변수로 Fightable 인터페이스를 구현한 클래스의 인스턴스를 넘겨줘야한다
            
            ```java
            interface Fight extends Unit implements Fightable {
            	public void attack(Fightable f)}
            	
            	있을 때 attack(new Fighter()) 
            				Fighter mothod(){
            				Fighter f = new Fighter();
            				return f;	}
            	할수있음
            	-> 리턴 타입이 인.페라는 것은 메서드가 해당 인페를 
            	구현한 클래스의 인스턴스를 반환한다는 것 (p.389)
            	
            ```
            
    - 인터페이스 장점
        - 개발시간 단축
        - 표준화 가능 → 인터페이스로 먼저 틀을 잡아두기 때문
        - 서로 관계없는 클래스들에게 관계를 맺어줄 수 있다 → ex) 서로 상속,같은 조상클래스X ⇒하나의 인터페이스를 공통적으로 구현하여 묶어줄 수 있음
        - 독립적인 프로그래밍 가능 → 선언과 구현을 분리시킬 수 있어 독립적 프로그래밍 가능, 클과 클 관계도 인페를 이용해 간접적인 관계로 변경하여 독립적 프밍 가능
    - 인터페이스의 이해
        - 클래스를 사용하는 쪽 (user)과 클래스를 제공하는 쪽(provider)이 있다
        - 메서드를 사용하는 쪽에서 사용하려는 메서드의 선언부만 알면 된다
            
            ```java
            class A {
            	public void methodA(B b){
            	b.methodB();}
            }
            
            class B {
            	public void methodB(){
            	System.out.println("methodB()");}
            }
            
            class Interface{
            	public static void main(String args[]){
            	A a = new A();
            	a.methodA(new B());
            	}
            }
            A는 클래스 B의 인스턴스를 생성하고 메서드를 호출하므로 A가 user B가 provider
            클래스 A를 작성하려면 클래스B가 이미 작성되어있어야함
            독립적 프밍을 위해 인터페이스 활용
            
            + interface I{public abstract void methodB();}
            
            -> class B implements I {
            	public void methodB(){
            	System.out.println("methodB in B class");}
            }
            -> class A {
            	public void methodA(I i){
            	i.methodB();}
            }
            
            == A-B 직접적 관계에서 A-I-B 간접적인 관계로 바뀜
            -> 클래스 A는 여전히 B의 메서드를 호출하지만 간접적이기 때문에 B의 변경에 영향을 받지않음
            == 오로지 I의 영향만 받음
            
            ```
            
    - 디폴트 메서드와 static 메서드
        - 인터페이스 → 추상 메서드 & 디폴트 메서드 & static 메서드 선언 가능
        - 디폴트메서드 → 추상 메서드의 기본적인 구현을 제공하는 메서드
            
             → 추상메서드가 아니기 때문에 디폴트 메서드가 새로 추가되어도 해당 인스턴스를 구현한 클래스는 변경안해도됨
            
            - default + → 몸통이 있어야하고 public(생략가능)
            - void newMethod(); (추상메서드) → default void newMethod();
            - 충돌하는 경우가 생길 수 있음
                - 여러 인터페이스의 디폴트 메서드간의 충돌
                    - 인페 구현한 클래스에서 디폴트 메서드를 오버라이딩(변경)해야된다
                - 디폴트 메서드와 조상 클래스의 메서드간의 충돌
                    - 조상 클래스의 메서드가 상속되고, 디폴트 메서드는 무시된다
                        
                        ```java
                        
                        class Child extends Parent implements MyInterface, MyInterface2 {
                         public void method1 () 
                        	System.out.println("method1() in Child"); // 오버라이딩  
                        }
                        interface MyInterface {
                        	default void methodl () ( System.out.println("method1() in MyInterface"); 
                        	 default void method2 () System.out.println("method2() in MyInterface"); } 
                        
                        ```
                        
    
    ![스크린샷 2025-10-12 오전 10.16.18.png](attachment:1261f809-1a12-433a-8d3e-3f067783efca:스크린샷_2025-10-12_오전_10.16.18.png)
    
    ![스크린샷 2025-10-12 오전 10.16.29.png](attachment:eec93cf2-7934-4e53-8325-442019564bb1:스크린샷_2025-10-12_오전_10.16.29.png)
    
8. **내부클래스**
    - 클래스내에 선언된 클래스 → 두 클래스가 서로 긴밀한 관계에 있기 때문
        
        ![KakaoTalk_Photo_2025-10-12-11-12-25.jpeg](attachment:96f37f88-4366-4c56-83a9-cbca52a1aa4b:KakaoTalk_Photo_2025-10-12-11-12-25.jpeg)
        
    - 내부 클래스 선언
        
        ```java
        class Outer{
        int iv = 0;
        static int cv = 0;
        
        void myMethod(){int iv = 0;}}
        
        ->
        class Outer{
        class In{}
        static class StaticIn{}
        
        void myMethod(){class LocalInner}}
        ```
        
    
    - 내부클래스의 제어자와 접근성
        - public, protected, default, private 모두 사용가능
        - abstract, final도 사용가능
        - 인스턴스 클래스는 static클래스의 멤버들을 객체 생성 없이 사용할 수 있지만 반대는 안됨
    - 익명 클래스
    - new 조상클래스 이름() { //멤버선언 }

or

new 구현인터페이스 이름() { //멤버선언 }

class InnerEx6{
	Object iv = new Object() {void method(){}}; //익명클래스
	static Object cv = new Object() {void method(){}}; //익명클래스
	
	void myMethod(){
	Object lv = new Object() {void method(){}}; //익명클래스
}

-> InnerEx6.class
	 InnerEx6$1.class
	 InnerEx6$2.class
	 InnerEx6$3.class
